Right now we are going to plan out this app. First I am going to tell you what the app is that we are building, delimiated by <app-plan></app-plan> tags, then I will tell you about the tech stack and coding practices delimiated by <tech></tech> tags, then we are going to analyze the existing datamodels by reading through all the files in ./libs/data/migrations/* as well as all the non test files in ./libs/data/pkg/* (excluding gen/), then we are going to make a battle plan on how to build the rest of the app. Nothing is set in stone. If you think there is a better way to model the existing data, please make your suggestions.

By the end of this planning session, I want (1) all the datamodels flushed out, and their sql written (2) feature breakdowns including tasks for people/llm agents to complete (3) Rule .md files that can be used to keep smaller llms models writing clean code. These should be saved somewhere within the repo to be reference by people and llm agents later.

This is a discussion. If you have any questions about the business's proccesses, or how the app will be used, please ask those questions before building the plan.

<app-plan>
The app is an ecommerce platform for a company name "GlassAct Studios." GlassAct studios makes custom stained glass inlays for the memorial industry. This provides a way to have truley permanent color on a gravestone. The glass is put through a very special proccess that ensures it is hard enough to last forever on a gravestone. The glass is ordered from a stained glass provider in sheets. These sheets need to go into a kiln to be fused to a backing peice of glass (this gives it thickness and strength). The anealed glass is then cut with a waterjet into the various designs. The cut glass is then put back into the oven to be fire polished. It is then packaged, glued onto a sheet of plexy glass with the correct spacing and orientation, and then shipped to our customer - a gravestone engraver. From that point, it is up to the gravestone engraver to sandblast out a cavity in the stone the same shape as the inlay (we provide the sandblast stencil), then they epoxy the glass in for a permanent bond. Our business is not end customer facing, and this platform is only for the gravestone engravers to purchase our product on behalf of the ones buying the stone.

So now that you know about the business, lets talk about the app! The thing that makes this different then other ecommerce platforms is that the proccess of ordering an inlay is usually a conversation. There are two ways to order an inlay - from the catalog, or custom. When ordering from the catalog, they can provide us with the id (A-BRD-0003L) of an inlay we have already designed. These inlays have a default size, a minimum size, and a price-group (pg for short). The customer can also ask for customizations they would like made to the design - maybe they want a different color for some of the peices that make up the inlay (or in rare cases, have the design tweeked). For custom inlays, they will usually tell us what they have in mind, and provide several photos to give us an idea of what they want an inlay of. We will then have a designer draw up what that inlay might look like. The customer can give their feedback and tweeks to the design will be made until our customer (the gravestone engraver) and their customer (the loved one purchasing the gravestone) are happy.

Once everyone is happy with the design, the order can be placed (This is a separate step from approving the design). When the order is placed, it gets put into a Kanban for us to work on. The steps of the kanban are: Inlay ordered -> Materials Prepped -> Inlay Cut -> Fire Polished -> Packaged -> Shipped.

After it is shipped, hopefully some webhooks from the shipper will keep the project up to date into Delivered. After the inlay is delivered there is an invoicing step. An invoice is made and emailed to the customer. When they pay the invoice, the order is done!

Here are some additional features of the app. We call the gravestone engravers "dealerships". There needs to be a place for us to manage the dealerships selling our product. Some of them have exclusivity deals over a certain area, so we need to know the location of the dealerships. That being said, this app will not keep track of those exclusivity deals.

Users need to be able to be added to the dealerships. These users should have configurable permissions for all the features of the apps. Dealer admins should be able to add a user that is able to submit a project, add its inlays, but not place the order.

One of the big features of the app is notifications. Whenever the dealership needs to approve an inlay design, they should be notified. Whenever an invoice is attached to a project, they should be notified. Whenever an inlay moves through the proccess, or gets blocked at a step, they should be notified. Notifications are primarily email, but I think having texting capabilities would be cool. They should be able to opt in or opt out of any different type of notification we may send them. They should also be able to configure it so notifications make it to different people.

Dealerships should be able to see the status of all their projects in an easy to read page (maybe with pizza trackers). It should be clear what projects are on hold because they need to take action in some way (approve or decline a design, pay an invoice, place the order, ect).

When they place an order, its not uncommon to order multiple inlays for the same stone. For this reason, inlays are grouped into projects. A project can have as many inlays as they want, but they cannot place an order for a project, unless they have accepted the proof for every inlay. (The can remove an inlay from a project if they no longer want it). Each inlay should have its own chat where the customer can talk to us, until we are certain what their wants are.

From glassacts perspective, we should also be able to cleaely see what projects are waiting on us to proceed (waiting for a design to be made, an invoice to be attached, a chat to be responded too, ect). Ordered inlays should pop up in the kanban, and the should move across the steps. If there is ever a problem, lets say we don't have the materials we need for an inlay and need to order more (or maybe a peice broke during manufacturing), there should be a way for us to mark a problem with that inlay (and the dealership should be notified). That problem should be able to be resolved, and the inlay can proceed (and the dealership should be notified).

Dealerships placing an order should have a view of the catalog that they can shop from. They should also have a place to request the changes they want from the standard catalog offering. 

Glassact should have a place to manage the catalog.

This is not going to be in the MVP, but in the future I want a graphical editor where dealerships can resize and recolor catalog items themself while placing the order. The datamodels should be ready for this eventuallity.
</app-plan>

<tech>
The frontend is built in solid.js. Here are the dependancies so far:

"dependencies": {
    "@atlaskit/pragmatic-drag-and-drop": "^1.7.7",
    "@atlaskit/pragmatic-drag-and-drop-auto-scroll": "^2.1.5",
    "@fontsource-variable/roboto": "^5.2.9",
    "@glassact/ui": "workspace:*",
    "@tanstack/solid-form": "catalog:",
    "@tanstack/solid-query": "^5.90.23",
    "@tanstack/solid-query-devtools": "^5.91.3",
    "@tanstack/solid-router": "catalog:",
    "@tanstack/solid-router-devtools": "^1.157.18",
    "@tanstack/solid-table": "^8.21.3",
    "axios": "^1.13.4",
    "immer": "^11.1.3",
    "solid-icons": "^1.2.0",
    "solid-js": "catalog:solid",
    "zod": "^4.3.6"
},
"devDependencies": {
    "@glassact/data": "workspace:*",
    "@tanstack/router-plugin": "^1.157.18",
    "autoprefixer": "^10.4.24",
    "postcss": "^8.5.6",
    "tailwindcss": "catalog:",
    "typescript": "catalog:",
    "vite": "^7.3.1",
    "vite-plugin-checker": "^0.12.0",
    "vite-plugin-solid": "^2.11.10"
}


The frontend consumes two libraries in our monorepo. @glassact/ui is where we build the solid components. This is largely built on solidjs shadcn clones. Here are those dependancies.
"dependencies": {
    "@kobalte/core": "^0.13.11",
    "@tanstack/solid-form": "catalog:",
    "@tanstack/solid-router": "catalog:",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "solid-js": "catalog:solid",
    "tailwind-merge": "^2.6.1",
    "tailwindcss": "catalog:",
    "tailwindcss-animate": "^1.0.7"
},
"devDependencies": {
    "typescript": "catalog:"
}

@glassact/data is a multilanguage library containing typescript types for the app, as well as a golang database layer. Here are its dependancies:
"devDependencies": {
    "type-fest": "^4.41.0",
    "typescript": "catalog:"
}

The typescript types are built around some helpers.
interface Metadata {
  created_at: string;
  updated_at: string;
  version: number;
}

interface DoubleId {
  id: number;
  uuid: string;
}

export type hasMetadata<T> = Tagged<T, "Metadata", Metadata>;
export type hasDoubleId<T> = Tagged<T, "DoubleId", DoubleId>;
export type StandardTable<T> = hasMetadata<hasDoubleId<T>>;

export type GET<T> = SimplifyDeep<deepAddBoth<addBoth<T>>>;
export type POST<T> = SimplifyDeep<deepSafeUnwrap<safeUnwrap<T>>>;
export type PATCH<T> = SimplifyDeep<Partial<deepAddDoubleId<addDoubleId<T>>>>;
export type PUT<T> = SimplifyDeep<deepAddDoubleId<addDoubleId<T>>>;

Here is how those are used.

import { StandardTable } from "./helpers";

export type Account = StandardTable<{
  user_id: number;
  type: string;
  provider: string;
  provider_account_id: string;
}>;

This means GET<Account> looks like
{
    id: number;
    uuid: string;
    user_id: number;
    type: string;
    provider: string;
    provider_account_id: string;
    created_at: string;
    updated_at: string;
    version: number;
}
Whereas POST<Account> looks like
{
    user_id: number;
    type: string;
    provider: string;
    provider_account_id: string;
}

I hate redundant comments. The code should always be self explainatory. Comments should only be there if and only if the code is not self explainatory for a valid reason.

Queries should happen in app/queries and should fully utilize tanstack/query. Here is an example query
export async function getDealerships(): Promise<GET<Dealership>[]> {
  const res = await api.get("/dealership");
  return res.data;
}

export function getDealershipsOpts() {
  return queryOptions({
    queryKey: ["dealership"],
    queryFn: getDealerships,
  });
}

then in the component using the query:
const query = useQuery(() => getDealershipsOpts());

The idea throught all the code in this project is to use external dependancies only when they carry their weight. Tanstack - GOLD. is-odd - get outa here.

The backend is written in golang. Standard libraries are used as much as possible. SQL is abstracted in the datalayer using Jet. 

Here is the current golang dependancy list.

github.com/aws/aws-sdk-go-v2 v1.41.0
github.com/aws/aws-sdk-go-v2/config v1.32.6
github.com/aws/aws-sdk-go-v2/credentials v1.19.6
github.com/aws/aws-sdk-go-v2/service/s3 v1.95.0
github.com/go-jet/jet/v2 v2.14.1
github.com/go-playground/validator/v10 v10.26.0
github.com/golang-migrate/migrate/v4 v4.19.1
github.com/google/uuid v1.6.0
github.com/jackc/pgx/v5 v5.7.4
github.com/joho/godotenv v1.5.1
github.com/justinas/alice v1.2.0
github.com/stretchr/testify v1.11.1
github.com/testcontainers/testcontainers-go v0.40.0
github.com/testcontainers/testcontainers-go/modules/postgres v0.40.0
golang.org/x/oauth2 v0.34.0

The entire app is using pnpm as its monorepo facilitator. Go scripts are aliased using pnpm scripts. In a sense pnpm is our make or mise.
</code>
